\newsection{Method Overloading}

\subsection{Motivation}
Now that we know how to make instance and class methods, we want to be able to have multiple methods of the same name but take different arguments. This process is called ``method overloading".

\subsection{Overloading}
Method overloading is when the following criteria are met (assume 2 methods):
\begin{itemize}
\item The methods are in the same class
\item The methods have the same \verb|return| type and method name
\item The methods have a different number or type of parameters (a different ``method signature")
\end{itemize}

For example, if we want to have a method called \verb|print| and want to print ``double" if the input is a \verb|double|, and ``int" if the input is an \verb|int|, we probably will design our code like this:
\begin{lstlisting}
public void print(double d) {
     System.out.print("double");
}
// overloaded method:
public void print(int i) {
     System.out.print("int");
}
\end{lstlisting}
However, if we have multiple methods with the same name, same parameters, but a different type, we have a compiler error. The reason for this is that there can be ambiguity in which method to choose. For example, the following methods will cause a compilation error:

\begin{lstlisting}
public int method() {
     return 0;
}
// overloaded method, causes compilation error:
public long method() {
     return 0;
}
\end{lstlisting}
We can see that method overloading is generally used for providing different functionality to different types of inputs, whether that be the number of them, or their types. 

\subsection{Written Exercises}

\begin{enumerate}

\item What is method overloading? 

\item What are the valid method headings assuming they are written in the same class?
\begin{lstlisting}
public void v()
public double v()

public double f2()
public double f2(int d)

public double sum(int left, int right)
public int sum(int left, int right)

public String s(int n)
public int S(int n)
\end{lstlisting}

\end{enumerate}